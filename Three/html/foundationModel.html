<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>基础模型</title>
	<style type="css">
		body {
      margin: 0;
			overflow: hidden;
		}
		*{
			margin: 0;
			padding: 0;
		}
		#info {
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			z-index: 100;
			display:block;
		}
	</style>
	<script type="text/javascript" src="../js/three.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.151.3/three.min.js"></script>
	<script type="text/javascript" src="../js/controls/OrbitControls.js"></script>
</head>
<body>
	<!-- 创建文字 -->
	<div id="info">Description</div>
	<!-- 创建canvas -->
	<canvas id="canvasId"></canvas>
	<script>

		init();

		function init() {
			// 设置浏览器窗口宽高
			var width = window.innerWidth
			var height = window.innerHeight

			// 场景 Scene
			var scene = new THREE.Scene()
			// 相机 Camera
			// 具有透视效果
			/*
			* PerspectiveCamera 透视相机
			* 构造函数 PerspectiveCamera(fov,aspect,near,far)
			* fov 视野角度 相机的视物体的垂直视野角  默认为50° 从下到上
			* aspect 相机视物体的长宽比  默认为1
			* near 相机视物体的近平面  默认为0.1
			* far 相机视物体的远平面  默认为2000
			*/
			var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 800)

			cameraFun(camera, 10, 20, 30);

			function cameraFun(camera, x, y, z) {
				camera.position.x = x
				camera.position.y = y
				camera.position.z = z
				camera.lookAt(scene.position)
			}

			// 渲染器 Renderer
			var renderer = new THREE.WebGLRenderer()
			// 设置背景颜色和尺寸
			// renderer.setClearColor(0xffffff)
			// renderer.setClearColor(0x000000)
			rendererFun(renderer, 0xffffff, width, height)

			function rendererFun(renderer, color, width, height){
				renderer.setClearColor(color);
				renderer.setSize(width,height);
			}

			// 几何体
			var cubeGeometry = new THREE.BoxGeometry(8,8,8)
			//  创建材质
			/*
			* 基础网格材质
			* color: 设置材质颜色
			* wireframe: 如果为true,则将材质渲染为线框，在调试时可以起到很好的作用
			* wireframeLinewidth: wireframe为true时，设置线框中线的宽度
			* wireframeLinecap: 决定线框端点如何显示，可选值 round bevel(斜角) miter(尖角)
			* vertexColors: 定义顶点的颜色，在canvasRender中不起作用
			* fog: 决定单个材质是否受全局雾化的影响
			*/
			const materialFirst = new THREE.LineBasicMaterial({ color: 0x0000ff });
			const points = [];
			points.push( new THREE.Vector3(-10, 0, 0) );
			points.push( new THREE.Vector3(0, 10, 0) );
			points.push( new THREE.Vector3(10, 0, 0) );

			const geometryFirst = new THREE.BufferGeometry().setFromPoints( points );

			const lineFirst = new THREE.Line(geometryFirst, materialFirst);

			scene.add(lineFirst)

			var cubeMaterial = new THREE.MeshBasicMaterial({
				color: 0xff0000,
				wireframe: true
			})
			// 创建立方体网格(mesh)
			var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
			cube.position.x = 0
			cube.position.y = 2
			cube.position.z = 0

			// 添加物体到场景中
			scene.add(cube)
			// 将渲染器的输出（canvas）插入到body中
			document.body.appendChild(renderer.domElement)

			// 渲染场景
			/**
       * [animate description]
       * Langery 2018-12-03
       * requestAnimationFrame 当用户切换到其他标签的时候,它会暂停,不会浪费处理器资源以及耗损电池的使用寿命
       */
			// renderer.render(scene, camera)
      function animate() {
      	requestAnimationFrame(animate);

      	renderer.render(scene, camera);

				// 运行轨迹动画
				// rotationFun();
      }

			// 旋转轨迹动画
			function rotationFun() {
				// 旋转速度频率
				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;
			}
      animate();
		}
	</script>
</body>
</html>
